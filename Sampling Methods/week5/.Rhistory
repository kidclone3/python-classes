list1 <- list(
a = c(1,2,3)
)
matrix1 <- matrix(data = c(1,2,3,4,5,6), ncol=3)
View(matrix1)
x <- 1:9
dbinom(10, size=50, prob=0.25)
x = 0:50
p = dbinom(x, 50, 0.25)
sum(x*p)
# Chỉ số IQ của 1 người được cho là tuân theo phân bố chuẩn, bới gtri trung bình là 100, độ lệch chuẩn là 15.
# Một người được coi là bình thường nếu có IQ
pnorm(115, 100, 15) - pnorm(85,100, 15)
diff(pnorm(c(85, 115), 100, 15))
# readxl Nhập dữ liệu từ file excel
library(readxl)
install.packages(readxl)
install.packages("readxl")
# readxl Nhập dữ liệu từ file excel
library(readxl)
pwd
ls
getwd()
A <- read_excel("~/Documents/bb5.xlsx")
View(A)
# 1. Nhập vào R hai vectơ sau:
#   X = (1 2 3 4 5 6 7 8 9);
#   Y = (1.5 2.3 3.2 4.6 5.4 6.6 7.6 8.6 9.1).
#   a) Tính độ dài hai vectơ.
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
# d) Làm tròn giá trị các phần tử của Y.
# e) Tính tổng X + Y; tích của 5 và Y.
X <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
# 1. Nhập vào R hai vectơ sau:
#   X = (1 2 3 4 5 6 7 8 9);
#   Y = (1.5 2.3 3.2 4.6 5.4 6.6 7.6 8.6 9.1).
#   a) Tính độ dài hai vectơ.
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
# d) Làm tròn giá trị các phần tử của Y.
# e) Tính tổng X + Y; tích của 5 và Y.
X <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
Y <- c(1.5, 2.3, 3.2, 4.6, 5.4, 6.6, 7.6, 8.6, 9.1)
#a) Tính độ dài hai vectơ.
X.length
#a) Tính độ dài hai vectơ.
length(X)
length(Y)
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
X[1]
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
X[2]
Y[c(1,4,7)]
Y <- replace(Y, c(1, 5), c(99, 199))
Y
X
Y
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
X[4] = 215
X
Y
X
Y
# d) Làm tròn giá trị các phần tử của Y.
round(Y)
Y
# d) Làm tròn giá trị các phần tử của Y.
Y <- round(Y)
# e) Tính tổng X + Y; tích của 5 và Y.
X + Y
5 * Y
Y
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
# d) Đưa ra ma trận D với D là ma trận cỡ 2x4 gồm các phần tử ở hàng 1 và hàng 2
# của ma trận A.
# e) Đưa ra ma trận E với E là ma trận cỡ 4x3 gồm các phần tử trừ cột 3 của ma
# trận B.
# f) Tính ma trận chuyển vị và ma trận nghịch đảo của ma trận A.
# g) Đưa ra giá trị riêng và vectơ riêng của ma trận B.
# h) Tính định thức của ma trận B.
# i) Tính tích AB.
# j) Biết Z là tích của ma trận A và ma trận nghịch đảo của B. Tìm Z.
A = matrix(c(1, 2, 1, 3, 3, 4, 5, 4, 2, 4, 3, 2, 8, 7, 5, 1), ncol=4)
View(A)
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
# d) Đưa ra ma trận D với D là ma trận cỡ 2x4 gồm các phần tử ở hàng 1 và hàng 2
# của ma trận A.
# e) Đưa ra ma trận E với E là ma trận cỡ 4x3 gồm các phần tử trừ cột 3 của ma
# trận B.
# f) Tính ma trận chuyển vị và ma trận nghịch đảo của ma trận A.
# g) Đưa ra giá trị riêng và vectơ riêng của ma trận B.
# h) Tính định thức của ma trận B.
# i) Tính tích AB.
# j) Biết Z là tích của ma trận A và ma trận nghịch đảo của B. Tìm Z.
A <- matrix(c(1, 2, 1, 3, 3, 6, 5, 4, 2, 4, 3, 2, 8, 7, 5, 1), ncol=4)
B <- matrix(c(1, 2, 3, 4, 4, 1, 5, 3, 1, 7, 8, 9, 4, 6, 3, 7), ncol=4)
C <- matrix(B, dimnames = c('X', 'Y', 'Z', 'T'))
C <- matrix(B, dimnames = ['X', 'Y', 'Z', 'T'])
C <- matrix(B, dimnames = list('X', 'Y', 'Z', 'T'))
C <- matrix(B) #, dimnames = list('X', 'Y', 'Z', 'T'))
View(C)
C <- matrix(B, ncol=4) #, dimnames = list('X', 'Y', 'Z', 'T'))
View(C)
C <- matrix(A, ncol=4, dimnames = list('X', 'Y', 'Z', 'T'))
C <- A
rownames(C) <- c('X', 'Y', 'Z', 'T')
View(C)
colSums(B)
View(B)
rowSums(B)
View(B)
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
A[2][3]
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
A[2,3]
View(A)
sessionInfo()
mass
help(mass)
library(MASS)
library(MASS)
data <- Boston
View(data)
colMeans(data)
cov(data)
cor(data) # ma tran tuong quan
max(abs(cor(data))) # ma tran tuong quan
tuong_quan <- cor(data) # ma tran tuong quan
help(for)
mx <- 0
N <- length(data)
ans <- c(0,0)
for (i in 1:N) {
for (j in 1:N) {
if (i != j) {
if (abs(tuong_quan[i,j]) > mx) {
mx = abs(tuong_quan[i, j])
ans <- c(i, j)
}
}
}
}
print(colnames(data)[i], colnames(data)[j])
print(colnames(data))
colname <- colnames(data)
print(typeof(colname))
colname <- as.vector(colnames(data))
print(typeof(colname))
print(typeof(colname[1]))
print(colname[1])
print(colname[ans[0]], colname[ans[1]])
ans[0]
ans[1]
print(colname[ans[1]], colname[ans[2]])
ans[1]
ans[2]
colname[1]
colname[ans[1]]
print(colname[ans[1]] + " " + colname[ans[2]])
help(paste)
print(paste(c(colname[ans[1]], colname[ans[2]])))
# b. Tìm giá trị riêng và vecto riêng của ma trận tương quan mẫu.
eigen(tuong_quan)
# b. Tìm giá trị riêng và vecto riêng của ma trận tương quan mẫu.
eigen(tuong_quan)$value
help(eigen)
eigen(tuong_quan)$vector
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=1, function(x) {
print(shapiro.test(x)$p_value > 0.05)
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
print(shapiro.test(x)$p_value > 0.05)
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
shapiro.test(x)$p_value > 0.05
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
print(colnames(x))
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
shapiro.test(data[[x]])
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- sapply(colname, function(x) {
shapiro.test(data[[x]])
})
View(check_c)
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- sapply(colname, function(x) {
shapiro.test(data[[x]])
})
help("mahalanobis")
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
mahalanobis(data, colMeans(data), cov(data))
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
maha <- mahalanobis(data, colMeans(data), cov(data))
chisq.test(maha)
View(check_c)
install.packages("KernSmooth")
library(KernSmooth)
help("bkde2D")
do_thi <- bkde2D(data, bandwidth = sapply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = apply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data[,1:2], dpik))
View(do_thi)
plot(data, xlab=colname[1], ylab=colname[2])
plot(data, xlab=string(colname[1]), ylab=string(colname[2]))
plot(data)
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data[,1:2], dpik))
plot(data)
do_thi <- bkde2D(data[,1:2], bandwidth =c(data[,1], data[,2]))
View(data)
do_thi <- bkde2D(data, bandwidth =c(data$rm, data$dis))
plot(data)
plot(do_thi, xlab="RM", ylab = "DIS")
help(dpik)
do_thi <- bkde2D(data, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(data, xlab="RM", ylab = "DIS")
View(do_thi)
plot(dothi[,1:2], xlab="RM", ylab = "DIS")
plot(do_thi[,1:2], xlab="RM", ylab = "DIS")
plot(do_thi[1:2], xlab="RM", ylab = "DIS")
do_thi[1]
plot(x=do_thi[1], y=do_thi[2], xlab="RM", ylab = "DIS")
type(do_thi)
typeof(do_thi)
typeof(do_thi[1])
typeof(do_thi[1][1])
typeof(do_thi[1][1][1])
plot(x=do_thi$x1, y=do_thi$x2, xlab="RM", ylab = "DIS")
do_thi <- bkde2D(data, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(x=do_thi$x1, y=do_thi$x2, xlab="RM", ylab = "DIS")
plot(data, xlab="RM", ylab = "DIS")
plot(data, xlab = "RM", ylab = "DIS")
plot(data)
plot(data)
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, xlab = "rm", ylab = "dis", zlab = "density")
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, add=T)
x <- data[,c("rm", "dis")]
do_thi <- bkde2D(x, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(x, xlab = "RM", ylab = "DIS")
plot(x)
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, add=T)
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x)
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
help(persp)
rotate
install.packages("rotate")
install.packages("rotate.cloud")
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
maha <- mahalanobis(data, colMeans(data), cov(data))
chisq.test(maha)
install.packages("cloud")
install.packages("TeachingDemos")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
library("TeachingDemos")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat) #, xlab="rm", ylab="dis", zlab="density")
install.packages(tcltk)
install.packages("tcltk")
library("tcltk")
install.packages("XQuartz")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat , xlab="rm", ylab="dis", zlab="density")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat , xlab="rm", ylab="dis", zlab="density")
exit
Sys.which("pdflatex")
Sys.which("pdflatex")
Sys.which("xelatex")
Sys.which("lualatex")
tinytex::install_tinytex()
par(mfrow=c(1,3))
n^2
stratum_1 = c(97, 67, 42, 125, 25, 92, 105, 86, 27, 43, 45, 59, 53, 21)
stratum_2 = c(125, 155, 67, 96, 256, 47, 310, 236, 220, 352, 142, 190)
stratum_3 = c(142, 310, 495, 320, 196, 256, 440, 510, 396)
stratum_4 = c(167, 655, 220, 540, 780)
N = c(86, 72, 52, 30)
n = c(14, 12, 9, 5)
x_bar = c(mean(stratum_1), mean(stratum_2), mean(stratum_3), mean(stratum_4))
x_bar
s = c(var(stratum_1)^2, var(stratum_2)^2, var(stratum_3)^2, var(stratum_4)^2)
s
n^2
n^2*(1-n/N)*s/n
1-n/N
n/N
var_tau = sum(n^2*(1-n/N)*s^2/n)
N
n
N
n
setwd("~/Documents/mycodes/Classes/Multivariate Statistical Analysis/week2")
knitr::opts_chunk$set(echo = TRUE)
dl = read.csv("table1.csv")
x = dl[, c("X1", "X2", "X3")]
s = cov(x)
s
s
eicov = eigen(s)
eicov
eicov$values
eicov$vectors # vecto rieng
```{r setup, include=FALSE}
print(utils::getSrcDirectory(function(){}))
print(utils::getSrcFilename(function(){}, full.names = TRUE))
head(dl)
head(x)
pca = princomp(x)
summary(pca)
summary(pca, loadings=T)
pcacov = princomp(covmat=s)
summary(pcacov) # Tỉ lệ biến sai tổng cộng
summary(pcacov, loadings=T)
install.packages("ggbiplot")
version
library(ggplot2)
library(stats)
biplot(pca, col = c("grey", "black"))
# install.packages("stats")
library(stats)
biplot(pca, col = c("grey", "black"))
knitr::opts_chunk$set(echo = TRUE)
dl = read.csv("table2.csv")
setwd("~/Documents/mycodes/Classes/Multivariate_Statistical_Analysis/week6")
dl = read.csv("table2.csv")
head(dl)
head(dl[, -1])
x <-  dl[, -1]
eicov = eigen(x)
s <- cov(x)
s
eicov = eigen(s)
eicov$values
eicov$vectors
pcacov = princomp(covmat=s)
summary(pcacov, loadings=T)
tquan_mau = cor(x)
eicor = eigen(tquan_mau)
pcacor = princomp(cormat=tquan_mau)
summary(pcacor, loadings=T)
pcacor = princomp(covmat=tquan_mau)
summary(pcacor, loadings=T)
?princomp
x <-  dl[, 2:8]
s <- cov(x)
s
tquan_mau = cor(x)
eicov = eigen(s)
eicov$values
eicov$vectors
eicor = eigen(tquan_mau)
pcacov = princomp(covmat=s)
summary(pcacov, loadings=T)
pcacor = princomp(covmat=tquan_mau)
summary(pcacor, loadings=T)
x <-  dl[, -1]
tquan_mau = cor(x)
pcacor = princomp(covmat=tquan_mau)
summary(pcacor, loadings=T)
princomp
dl = read.csv("table2.csv")
head(dl[, -1])
x <-  dl[, -1]
s <- cov(x)
s
tquan_mau = cor(x)
eicov = eigen(s)
eicor = eigen(tquan_mau)
pcacov = princomp(covmat=s)
summary(pcacov, loadings=T)
pcacor = princomp(covmat=tquan_mau)
summary(pcacor, loadings=T)
setwd("~/Documents/mycodes/Classes/Sampling Methods/week5")
