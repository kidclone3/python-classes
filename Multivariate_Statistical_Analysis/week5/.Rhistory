list1 <- list(
a = c(1,2,3)
)
matrix1 <- matrix(data = c(1,2,3,4,5,6), ncol=3)
View(matrix1)
x <- 1:9
dbinom(10, size=50, prob=0.25)
x = 0:50
p = dbinom(x, 50, 0.25)
sum(x*p)
# Chỉ số IQ của 1 người được cho là tuân theo phân bố chuẩn, bới gtri trung bình là 100, độ lệch chuẩn là 15.
# Một người được coi là bình thường nếu có IQ
pnorm(115, 100, 15) - pnorm(85,100, 15)
diff(pnorm(c(85, 115), 100, 15))
# readxl Nhập dữ liệu từ file excel
library(readxl)
install.packages(readxl)
install.packages("readxl")
# readxl Nhập dữ liệu từ file excel
library(readxl)
pwd
ls
getwd()
A <- read_excel("~/Documents/bb5.xlsx")
View(A)
# 1. Nhập vào R hai vectơ sau:
#   X = (1 2 3 4 5 6 7 8 9);
#   Y = (1.5 2.3 3.2 4.6 5.4 6.6 7.6 8.6 9.1).
#   a) Tính độ dài hai vectơ.
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
# d) Làm tròn giá trị các phần tử của Y.
# e) Tính tổng X + Y; tích của 5 và Y.
X <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
# 1. Nhập vào R hai vectơ sau:
#   X = (1 2 3 4 5 6 7 8 9);
#   Y = (1.5 2.3 3.2 4.6 5.4 6.6 7.6 8.6 9.1).
#   a) Tính độ dài hai vectơ.
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
# d) Làm tròn giá trị các phần tử của Y.
# e) Tính tổng X + Y; tích của 5 và Y.
X <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
Y <- c(1.5, 2.3, 3.2, 4.6, 5.4, 6.6, 7.6, 8.6, 9.1)
#a) Tính độ dài hai vectơ.
X.length
#a) Tính độ dài hai vectơ.
length(X)
length(Y)
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
X[1]
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
X[2]
Y[c(1,4,7)]
Y <- replace(Y, c(1, 5), c(99, 199))
Y
X
Y
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
X[4] = 215
X
Y
X
Y
# d) Làm tròn giá trị các phần tử của Y.
round(Y)
Y
# d) Làm tròn giá trị các phần tử của Y.
Y <- round(Y)
# e) Tính tổng X + Y; tích của 5 và Y.
X + Y
5 * Y
Y
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
# d) Đưa ra ma trận D với D là ma trận cỡ 2x4 gồm các phần tử ở hàng 1 và hàng 2
# của ma trận A.
# e) Đưa ra ma trận E với E là ma trận cỡ 4x3 gồm các phần tử trừ cột 3 của ma
# trận B.
# f) Tính ma trận chuyển vị và ma trận nghịch đảo của ma trận A.
# g) Đưa ra giá trị riêng và vectơ riêng của ma trận B.
# h) Tính định thức của ma trận B.
# i) Tính tích AB.
# j) Biết Z là tích của ma trận A và ma trận nghịch đảo của B. Tìm Z.
A = matrix(c(1, 2, 1, 3, 3, 4, 5, 4, 2, 4, 3, 2, 8, 7, 5, 1), ncol=4)
View(A)
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
# d) Đưa ra ma trận D với D là ma trận cỡ 2x4 gồm các phần tử ở hàng 1 và hàng 2
# của ma trận A.
# e) Đưa ra ma trận E với E là ma trận cỡ 4x3 gồm các phần tử trừ cột 3 của ma
# trận B.
# f) Tính ma trận chuyển vị và ma trận nghịch đảo của ma trận A.
# g) Đưa ra giá trị riêng và vectơ riêng của ma trận B.
# h) Tính định thức của ma trận B.
# i) Tính tích AB.
# j) Biết Z là tích của ma trận A và ma trận nghịch đảo của B. Tìm Z.
A <- matrix(c(1, 2, 1, 3, 3, 6, 5, 4, 2, 4, 3, 2, 8, 7, 5, 1), ncol=4)
B <- matrix(c(1, 2, 3, 4, 4, 1, 5, 3, 1, 7, 8, 9, 4, 6, 3, 7), ncol=4)
C <- matrix(B, dimnames = c('X', 'Y', 'Z', 'T'))
C <- matrix(B, dimnames = ['X', 'Y', 'Z', 'T'])
C <- matrix(B, dimnames = list('X', 'Y', 'Z', 'T'))
C <- matrix(B) #, dimnames = list('X', 'Y', 'Z', 'T'))
View(C)
C <- matrix(B, ncol=4) #, dimnames = list('X', 'Y', 'Z', 'T'))
View(C)
C <- matrix(A, ncol=4, dimnames = list('X', 'Y', 'Z', 'T'))
C <- A
rownames(C) <- c('X', 'Y', 'Z', 'T')
View(C)
colSums(B)
View(B)
rowSums(B)
View(B)
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
A[2][3]
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
A[2,3]
View(A)
sessionInfo()
mass
help(mass)
library(MASS)
library(MASS)
data <- Boston
View(data)
colMeans(data)
cov(data)
cor(data) # ma tran tuong quan
max(abs(cor(data))) # ma tran tuong quan
tuong_quan <- cor(data) # ma tran tuong quan
help(for)
mx <- 0
N <- length(data)
ans <- c(0,0)
for (i in 1:N) {
for (j in 1:N) {
if (i != j) {
if (abs(tuong_quan[i,j]) > mx) {
mx = abs(tuong_quan[i, j])
ans <- c(i, j)
}
}
}
}
print(colnames(data)[i], colnames(data)[j])
print(colnames(data))
colname <- colnames(data)
print(typeof(colname))
colname <- as.vector(colnames(data))
print(typeof(colname))
print(typeof(colname[1]))
print(colname[1])
print(colname[ans[0]], colname[ans[1]])
ans[0]
ans[1]
print(colname[ans[1]], colname[ans[2]])
ans[1]
ans[2]
colname[1]
colname[ans[1]]
print(colname[ans[1]] + " " + colname[ans[2]])
help(paste)
print(paste(c(colname[ans[1]], colname[ans[2]])))
# b. Tìm giá trị riêng và vecto riêng của ma trận tương quan mẫu.
eigen(tuong_quan)
# b. Tìm giá trị riêng và vecto riêng của ma trận tương quan mẫu.
eigen(tuong_quan)$value
help(eigen)
eigen(tuong_quan)$vector
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=1, function(x) {
print(shapiro.test(x)$p_value > 0.05)
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
print(shapiro.test(x)$p_value > 0.05)
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
shapiro.test(x)$p_value > 0.05
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
print(colnames(x))
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
shapiro.test(data[[x]])
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- sapply(colname, function(x) {
shapiro.test(data[[x]])
})
View(check_c)
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- sapply(colname, function(x) {
shapiro.test(data[[x]])
})
help("mahalanobis")
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
mahalanobis(data, colMeans(data), cov(data))
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
maha <- mahalanobis(data, colMeans(data), cov(data))
chisq.test(maha)
View(check_c)
install.packages("KernSmooth")
library(KernSmooth)
help("bkde2D")
do_thi <- bkde2D(data, bandwidth = sapply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = apply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data[,1:2], dpik))
View(do_thi)
plot(data, xlab=colname[1], ylab=colname[2])
plot(data, xlab=string(colname[1]), ylab=string(colname[2]))
plot(data)
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data[,1:2], dpik))
plot(data)
do_thi <- bkde2D(data[,1:2], bandwidth =c(data[,1], data[,2]))
View(data)
do_thi <- bkde2D(data, bandwidth =c(data$rm, data$dis))
plot(data)
plot(do_thi, xlab="RM", ylab = "DIS")
help(dpik)
do_thi <- bkde2D(data, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(data, xlab="RM", ylab = "DIS")
View(do_thi)
plot(dothi[,1:2], xlab="RM", ylab = "DIS")
plot(do_thi[,1:2], xlab="RM", ylab = "DIS")
plot(do_thi[1:2], xlab="RM", ylab = "DIS")
do_thi[1]
plot(x=do_thi[1], y=do_thi[2], xlab="RM", ylab = "DIS")
type(do_thi)
typeof(do_thi)
typeof(do_thi[1])
typeof(do_thi[1][1])
typeof(do_thi[1][1][1])
plot(x=do_thi$x1, y=do_thi$x2, xlab="RM", ylab = "DIS")
do_thi <- bkde2D(data, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(x=do_thi$x1, y=do_thi$x2, xlab="RM", ylab = "DIS")
plot(data, xlab="RM", ylab = "DIS")
plot(data, xlab = "RM", ylab = "DIS")
plot(data)
plot(data)
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, xlab = "rm", ylab = "dis", zlab = "density")
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, add=T)
x <- data[,c("rm", "dis")]
do_thi <- bkde2D(x, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(x, xlab = "RM", ylab = "DIS")
plot(x)
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, add=T)
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x)
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
help(persp)
rotate
install.packages("rotate")
install.packages("rotate.cloud")
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
maha <- mahalanobis(data, colMeans(data), cov(data))
chisq.test(maha)
install.packages("cloud")
install.packages("TeachingDemos")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
library("TeachingDemos")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat) #, xlab="rm", ylab="dis", zlab="density")
install.packages(tcltk)
install.packages("tcltk")
library("tcltk")
install.packages("XQuartz")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat , xlab="rm", ylab="dis", zlab="density")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat , xlab="rm", ylab="dis", zlab="density")
exit
Sys.which("pdflatex")
Sys.which("pdflatex")
Sys.which("xelatex")
Sys.which("lualatex")
tinytex::install_tinytex()
par(mfrow=c(1,3))
n^2
stratum_1 = c(97, 67, 42, 125, 25, 92, 105, 86, 27, 43, 45, 59, 53, 21)
stratum_2 = c(125, 155, 67, 96, 256, 47, 310, 236, 220, 352, 142, 190)
stratum_3 = c(142, 310, 495, 320, 196, 256, 440, 510, 396)
stratum_4 = c(167, 655, 220, 540, 780)
N = c(86, 72, 52, 30)
n = c(14, 12, 9, 5)
x_bar = c(mean(stratum_1), mean(stratum_2), mean(stratum_3), mean(stratum_4))
x_bar
s = c(var(stratum_1)^2, var(stratum_2)^2, var(stratum_3)^2, var(stratum_4)^2)
s
n^2
n^2*(1-n/N)*s/n
1-n/N
n/N
var_tau = sum(n^2*(1-n/N)*s^2/n)
N
n
N
n
setwd("~/Documents/mycodes/Classes/Multivariate Statistical Analysis/week5")
knitr::opts_chunk$set(echo = TRUE)
?rnorm()
X1 <- rnorm(1000, 0, sqrt(1)) # Sinh ra nn 1000 gt của x1
X2 <- rnorm(1000, 0, sqrt(1)) # Sinh ra nn 1000 gt của x1
X1 <- rnorm(1000, 0, sqrt(1)) # Sinh ra nn 1000 gt của x1
X2 <- rnorm(1000, 0, sqrt(1)) # Sinh ra nn 1000 gt của x1
install.packages("ellipse")
install.packages("ellipse")
library(ellipse)
install.packages("ellipse")
install.packages("ellipse")
library(ellipse)
X <- data.frame(X1, X2)
## Bài 2:
Cho trước ma trận hiệp phương sai và kỳ vọng mẫu. Sinh ngẫu nhiên 1000 giá trị của vecto ngẫu nhiên tương ứng. Kiểm định xem từng biến trong vectơ ngẫu nhiên có phân bố chuẩn 1-chiều không?
#íntall.packages("MASS")
library(MASS)
shapiro.test(X[,1])
library("datasets")
?lm()
thr = lm(mpg ~ cyl + disp, data = mtcars) # Biểu diễn HQTT của mpg theo cyl và disp
thr$coefficients
# Có sẵn trong quan sát: y[i] = mpg[i]
# Phần dư e[i] = y[i] - y_h[i]
e = ff$residuals
ff = lm(mpg ~ cyl + disp + hp, data = mtcars) # Biểu diễn HQTT của mpg theo cyl, disp và hp
summary(ff)
# Có sẵn trong quan sát: y[i] = mpg[i]
# Phần dư e[i] = y[i] - y_h[i]
e = ff$residuals
e
all = lm(mpg~., data=mtcars) # biểu diễn hqtt của mpg theo tất cả các biến còn lại
all
install.packages("stats")
install.packages("stats")
install.packages("stats")
?formula()
knitr::opts_chunk$set(echo = TRUE)
# step(object, scope, scale, direction, trace)
# object = only/all
# scope = formula(all)/formula(all) - formula(only)
# direction = "forward" / "backward"
# trace = 0
forward = step(object = only, scope = formula(all), direction = "forward", trace = 0)
only = lm(mpg ~ 1, data = mtcars) # Biểu diễn HQTT của mpg vs chính nó
only
# step(object, scope, scale, direction, trace)
# object = only/all
# scope = formula(all)/formula(all) - formula(only)
# direction = "forward" / "backward"
# trace = 0
forward = step(object = only, scope = formula(all), direction = "forward", trace = 0)
forward
# Tính toán từ mô hình đơn giản nhất đến mô hình phức tạp nhất
forward$anova
