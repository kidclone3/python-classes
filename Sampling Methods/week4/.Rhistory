list1 <- list(
a = c(1,2,3)
)
matrix1 <- matrix(data = c(1,2,3,4,5,6), ncol=3)
View(matrix1)
x <- 1:9
dbinom(10, size=50, prob=0.25)
x = 0:50
p = dbinom(x, 50, 0.25)
sum(x*p)
# Chỉ số IQ của 1 người được cho là tuân theo phân bố chuẩn, bới gtri trung bình là 100, độ lệch chuẩn là 15.
# Một người được coi là bình thường nếu có IQ
pnorm(115, 100, 15) - pnorm(85,100, 15)
diff(pnorm(c(85, 115), 100, 15))
# readxl Nhập dữ liệu từ file excel
library(readxl)
install.packages(readxl)
install.packages("readxl")
# readxl Nhập dữ liệu từ file excel
library(readxl)
pwd
ls
getwd()
A <- read_excel("~/Documents/bb5.xlsx")
View(A)
# 1. Nhập vào R hai vectơ sau:
#   X = (1 2 3 4 5 6 7 8 9);
#   Y = (1.5 2.3 3.2 4.6 5.4 6.6 7.6 8.6 9.1).
#   a) Tính độ dài hai vectơ.
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
# d) Làm tròn giá trị các phần tử của Y.
# e) Tính tổng X + Y; tích của 5 và Y.
X <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
# 1. Nhập vào R hai vectơ sau:
#   X = (1 2 3 4 5 6 7 8 9);
#   Y = (1.5 2.3 3.2 4.6 5.4 6.6 7.6 8.6 9.1).
#   a) Tính độ dài hai vectơ.
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
# d) Làm tròn giá trị các phần tử của Y.
# e) Tính tổng X + Y; tích của 5 và Y.
X <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)
Y <- c(1.5, 2.3, 3.2, 4.6, 5.4, 6.6, 7.6, 8.6, 9.1)
#a) Tính độ dài hai vectơ.
X.length
#a) Tính độ dài hai vectơ.
length(X)
length(Y)
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
X[1]
# b) Trích phần tử thứ 2 trong vectơ X và trích các phần tử thứ 1, 4, 7 trong vectơ
# Y.
X[2]
Y[c(1,4,7)]
Y <- replace(Y, c(1, 5), c(99, 199))
Y
X
Y
# c) Thay giá trị của phần tử thứ 4 trong X bởi 215. Thay các giá trị của các phần tử
# thứ 1, 5 trong Y bởi 99, 199.
X[4] = 215
X
Y
X
Y
# d) Làm tròn giá trị các phần tử của Y.
round(Y)
Y
# d) Làm tròn giá trị các phần tử của Y.
Y <- round(Y)
# e) Tính tổng X + Y; tích của 5 và Y.
X + Y
5 * Y
Y
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
# d) Đưa ra ma trận D với D là ma trận cỡ 2x4 gồm các phần tử ở hàng 1 và hàng 2
# của ma trận A.
# e) Đưa ra ma trận E với E là ma trận cỡ 4x3 gồm các phần tử trừ cột 3 của ma
# trận B.
# f) Tính ma trận chuyển vị và ma trận nghịch đảo của ma trận A.
# g) Đưa ra giá trị riêng và vectơ riêng của ma trận B.
# h) Tính định thức của ma trận B.
# i) Tính tích AB.
# j) Biết Z là tích của ma trận A và ma trận nghịch đảo của B. Tìm Z.
A = matrix(c(1, 2, 1, 3, 3, 4, 5, 4, 2, 4, 3, 2, 8, 7, 5, 1), ncol=4)
View(A)
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
# d) Đưa ra ma trận D với D là ma trận cỡ 2x4 gồm các phần tử ở hàng 1 và hàng 2
# của ma trận A.
# e) Đưa ra ma trận E với E là ma trận cỡ 4x3 gồm các phần tử trừ cột 3 của ma
# trận B.
# f) Tính ma trận chuyển vị và ma trận nghịch đảo của ma trận A.
# g) Đưa ra giá trị riêng và vectơ riêng của ma trận B.
# h) Tính định thức của ma trận B.
# i) Tính tích AB.
# j) Biết Z là tích của ma trận A và ma trận nghịch đảo của B. Tìm Z.
A <- matrix(c(1, 2, 1, 3, 3, 6, 5, 4, 2, 4, 3, 2, 8, 7, 5, 1), ncol=4)
B <- matrix(c(1, 2, 3, 4, 4, 1, 5, 3, 1, 7, 8, 9, 4, 6, 3, 7), ncol=4)
C <- matrix(B, dimnames = c('X', 'Y', 'Z', 'T'))
C <- matrix(B, dimnames = ['X', 'Y', 'Z', 'T'])
C <- matrix(B, dimnames = list('X', 'Y', 'Z', 'T'))
C <- matrix(B) #, dimnames = list('X', 'Y', 'Z', 'T'))
View(C)
C <- matrix(B, ncol=4) #, dimnames = list('X', 'Y', 'Z', 'T'))
View(C)
C <- matrix(A, ncol=4, dimnames = list('X', 'Y', 'Z', 'T'))
C <- A
rownames(C) <- c('X', 'Y', 'Z', 'T')
View(C)
colSums(B)
View(B)
rowSums(B)
View(B)
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
A[2][3]
# c) Đưa ra giá trị ở hàng 2, cột 3 của ma trận A.
A[2,3]
View(A)
sessionInfo()
mass
help(mass)
library(MASS)
library(MASS)
data <- Boston
View(data)
colMeans(data)
cov(data)
cor(data) # ma tran tuong quan
max(abs(cor(data))) # ma tran tuong quan
tuong_quan <- cor(data) # ma tran tuong quan
help(for)
mx <- 0
N <- length(data)
ans <- c(0,0)
for (i in 1:N) {
for (j in 1:N) {
if (i != j) {
if (abs(tuong_quan[i,j]) > mx) {
mx = abs(tuong_quan[i, j])
ans <- c(i, j)
}
}
}
}
print(colnames(data)[i], colnames(data)[j])
print(colnames(data))
colname <- colnames(data)
print(typeof(colname))
colname <- as.vector(colnames(data))
print(typeof(colname))
print(typeof(colname[1]))
print(colname[1])
print(colname[ans[0]], colname[ans[1]])
ans[0]
ans[1]
print(colname[ans[1]], colname[ans[2]])
ans[1]
ans[2]
colname[1]
colname[ans[1]]
print(colname[ans[1]] + " " + colname[ans[2]])
help(paste)
print(paste(c(colname[ans[1]], colname[ans[2]])))
# b. Tìm giá trị riêng và vecto riêng của ma trận tương quan mẫu.
eigen(tuong_quan)
# b. Tìm giá trị riêng và vecto riêng của ma trận tương quan mẫu.
eigen(tuong_quan)$value
help(eigen)
eigen(tuong_quan)$vector
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=1, function(x) {
print(shapiro.test(x)$p_value > 0.05)
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
print(shapiro.test(x)$p_value > 0.05)
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
shapiro.test(x)$p_value > 0.05
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
print(colnames(x))
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- apply(data, MARGIN=2, function(x) {
shapiro.test(data[[x]])
})
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- sapply(colname, function(x) {
shapiro.test(data[[x]])
})
View(check_c)
# c. Kiểm định xem từng biến có tuân theo phân phối chuẩn một chiều
# không?
check_c <- sapply(colname, function(x) {
shapiro.test(data[[x]])
})
help("mahalanobis")
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
mahalanobis(data, colMeans(data), cov(data))
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
maha <- mahalanobis(data, colMeans(data), cov(data))
chisq.test(maha)
View(check_c)
install.packages("KernSmooth")
library(KernSmooth)
help("bkde2D")
do_thi <- bkde2D(data, bandwidth = sapply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = apply(data, dpik))
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data[,1:2], dpik))
View(do_thi)
plot(data, xlab=colname[1], ylab=colname[2])
plot(data, xlab=string(colname[1]), ylab=string(colname[2]))
plot(data)
do_thi <- bkde2D(data[,1:2], bandwidth = sapply(data[,1:2], dpik))
plot(data)
do_thi <- bkde2D(data[,1:2], bandwidth =c(data[,1], data[,2]))
View(data)
do_thi <- bkde2D(data, bandwidth =c(data$rm, data$dis))
plot(data)
plot(do_thi, xlab="RM", ylab = "DIS")
help(dpik)
do_thi <- bkde2D(data, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(data, xlab="RM", ylab = "DIS")
View(do_thi)
plot(dothi[,1:2], xlab="RM", ylab = "DIS")
plot(do_thi[,1:2], xlab="RM", ylab = "DIS")
plot(do_thi[1:2], xlab="RM", ylab = "DIS")
do_thi[1]
plot(x=do_thi[1], y=do_thi[2], xlab="RM", ylab = "DIS")
type(do_thi)
typeof(do_thi)
typeof(do_thi[1])
typeof(do_thi[1][1])
typeof(do_thi[1][1][1])
plot(x=do_thi$x1, y=do_thi$x2, xlab="RM", ylab = "DIS")
do_thi <- bkde2D(data, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(x=do_thi$x1, y=do_thi$x2, xlab="RM", ylab = "DIS")
plot(data, xlab="RM", ylab = "DIS")
plot(data, xlab = "RM", ylab = "DIS")
plot(data)
plot(data)
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, xlab = "rm", ylab = "dis", zlab = "density")
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, add=T)
x <- data[,c("rm", "dis")]
do_thi <- bkde2D(x, bandwidth =c(dpik(data$rm), dpik(data$dis)))
plot(x, xlab = "RM", ylab = "DIS")
plot(x)
contour(x=do_thi$x1, y=do_thi$x2, z = do_thi$fhat, add=T)
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x)
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
help(persp)
rotate
install.packages("rotate")
install.packages("rotate.cloud")
# d. “Khoảng cách” có tuân theo phân phối Khi-bình phương không?
maha <- mahalanobis(data, colMeans(data), cov(data))
chisq.test(maha)
install.packages("cloud")
install.packages("TeachingDemos")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
library("TeachingDemos")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat, xlab="rm", ylab="dis", zlab="density")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat) #, xlab="rm", ylab="dis", zlab="density")
install.packages(tcltk)
install.packages("tcltk")
library("tcltk")
install.packages("XQuartz")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
rotate.persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat , xlab="rm", ylab="dis", zlab="density")
# g. Vẽ biểu đồ thể hiện rõ hàm mật độ hai chiều của hai biến rm và dis.
persp(x = do_thi$x1, y = do_thi$x2, z = do_thi$fhat , xlab="rm", ylab="dis", zlab="density")
exit
Sys.which("pdflatex")
Sys.which("pdflatex")
Sys.which("xelatex")
Sys.which("lualatex")
tinytex::install_tinytex()
setwd("~/Documents/mycodes/Classes/Sampling Methods/week4")
```{r}
sigma = c(6,5,3)
n = 30
sigma = c(6,5,3)
N = c(132,92,27)
sum_N_sigma = sum(N*sigma)
print(sum_N_sigma)
vecto_n
# find_sum_sigma <- function(N,sigma,c) {
# sum1 = 0
# sum2 = 0
# for (i in seq(length(N))) {
#       sum1 = sum1 + N[i]*sigma[i]*sqrt(c[i])
#       sum2 = sum2 + N[i]*sigma[i]/sqrt(c[i])
#   }
# sum1*sum2
# }
sum_sigma_mul_sqrt_c = sum(N*sigma*sqrt(c))
D = 0.1
c = c(9, 25, 36)
sigma = c(1.5, 1.8, 1.8)
N = c(112,68,39)
# find_sum_sigma <- function(N,sigma,c) {
# sum1 = 0
# sum2 = 0
# for (i in seq(length(N))) {
#       sum1 = sum1 + N[i]*sigma[i]*sqrt(c[i])
#       sum2 = sum2 + N[i]*sigma[i]/sqrt(c[i])
#   }
# sum1*sum2
# }
sum_sigma_mul_sqrt_c = sum(N*sigma*sqrt(c))
sum_sigma_divide_sqrt_c = sum(N*sigma/sqrt(c))
sum_sigma_c = sum_sigma_mul_sqrt_c * sum_sigma_divide_sqrt_c
sum_sigma_c_2 = sum(N*sigma^2)
find_n <- function(N,sigma,c,D) {
sum_n = sum(N)
n = sum_sigma_c / (sum_n^2 * D + sum_sigma_c_2)
n = round(n, 0)
n
}
find_n(N, sigma, c, D)
