help(combn)
x <- t(combn(dataX, n))
x
var(x) # sigma^2
mu <- mean(x)
colMeans(x)
rowMeans(x)
# mean for each sample.
x.mean = rowMeans(x)
y_bar = mean(x.mean)
y_bar2 = var(x.mean)
x.var = apply(x,1,var)
x.var
y_bar2 = mean(x.mean^2)
y_bar2 - y_bar^2
help(var)
var(y_bar)
var(y_bar.mean)
y_bar.mean <- rowMeans(x)
y_bar.mean
v_y_bar <- var(y_bar.mean)
v_y_bar^2
dataX <- c(0,1,2,3,4)
N <- length(dataX)
n <- 2
x <- t(combn(dataX, n))
y_bar.mean <- rowMeans(x)
y_bar.mean
v_y_bar <- var(y_bar.mean)
v_y_bar^2
v_y_bar <- sd(y_bar.mean)
v_y_bar <- var(x)
knitr::opts_chunk$set(echo = TRUE)
vectorize(y_bar)
y_bar <- rowMeans(x)
var(y_bar.mean)
typeof(y_bar)
v_y_bar <- var(x[1,])
v_y_bar <- var(x[,1])
v_y_bar <- var(y_bar[,1])
v_y_bar <- var(y_bar[1,])
v_y_bar <- var(y_bar)
y_bar <- as.vector(rowMeans(x))
v_y_bar <- var(y_bar)
y_bar[0]
y_bar[1]
y_bar[3]
len(y_bar)
length(y_bar)
v_y_bar <- var(y_bar)*(N-1)
y_bar <- as.vector(rowMeans(x))
v_y_bar <- var(y_bar)*(N-1)
v_y_bar <- var(y_bar)
y_bar.mean <- mean(y_bar)
y_bar.mean_2 <- mean(y_bar^2)
V_y_bar <- y_bar.mean_2 - y_bar.mean
V_y_bar <- y_bar.mean_2 - y_bar.mean^2
sigma = mean(x)
View(x)
x + t(y_bar)
merge(x, t(y_bar))
dataX <- c(1,2,3,4)
N <- length(dataX)
n <- 2
x <- t(combn(dataX, n))
mean(x)
dataX <- c(0,1,2,3,4)
N <- length(dataX)
n <- 2
x <- t(combn(dataX, n))
sigma = var(x)
sigma = var(as.vector(x))
mean(as.vector(x))
tmp <- apply(x, MARGIN = 1, function(x) {
print(x)
})
tmp <- apply(x, MARGIN = 1, function(x) {
print(x[0] +","+ x[1])
})
printf("%f, %f",x[0],x[1])
tmp <- apply(x, MARGIN = 1, function(x) {
printf("%f, %f",x[0],x[1])
})
tmp <- apply(x, MARGIN = 1, function(x) {
sprintf("%f, %f",x[0],x[1])
})
tmp
sprintf("%f,%f", x[1][1], x[1][2])
sprintf("%f,%f", x[1][0], x[1][1])
tmp <- apply(x, MARGIN = 1, function(x) {
sprintf("%f, %f",x)
})
tmp <- apply(x, MARGIN = 1, function(x) {
sprintf("%f",x)
})
tmp <- apply(x, MARGIN = 1, function(x) {
# sprintf("%f",x)
print(typeof(x))
})
tmp <- apply(x, MARGIN = 1, function(x) {
# sprintf("%f",x)
print(typeof(x[0]))
})
tmp <- apply(x, MARGIN = 1, function(x) {
# sprintf("%f",x)
print(typeof(x[1]))
})
tmp <- apply(x, MARGIN = 1, function(x) {
# sprintf("%f",x)
print(x[0])
})
tmp <- apply(x, MARGIN = 1, function(x) {
# sprintf("%f",x)
print(x[1])
})
tmp <- apply(x, MARGIN = 1, function(x) {
# sprintf("%f",x)
print(x[2])
})
tmp <- apply(x, MARGIN = 1, function(x) {
sprintf("%f,%f",x[1], x[2])
})
tmp <- apply(x, MARGIN = 1, function(x) {
cat(patse(sprintf("%f,%f",x[1], x[2])))
})
tmp <- apply(x, MARGIN = 1, function(x) {
cat(paste(sprintf("%f,%f",x[1], x[2])))
})
tmp <- apply(x, MARGIN = 1, function(x) {
cat(paste(sprintf("%f,%f\n",x[1], x[2])))
})
tmp <- apply(x, MARGIN = 1, function(x) {
cat(paste(sprintf("%d,%d\n",x[1], x[2])))
})
help(apply)
help(sapply)
sample <- apply(x, MARGIN = 1, function(x) {
cat(paste(sprintf("{%d,%d}",x[1], x[2])))
})
sample <- as.list(apply(x, MARGIN = 1, function(x) {
cat(paste(sprintf("{%d,%d}",x[1], x[2])))
}))
sample <- as.list(apply(x, MARGIN = 1, function(x) {
paste(sprintf("{%d,%d}",x[1], x[2]))
}))
View(sample)
y_bar <- as.vector(rowMeans(x))
y_bar <- as.list(rowMeans(x))
Sample <- as.list(apply(x, MARGIN = 1, function(x) {
paste(sprintf("{%d,%d}",x[1], x[2]))
}))
y_bar <- as.list(rowMeans(x))
data2 <- data.frame(Sample, y_bar)
View(data2)
Sample <- as.vector.data.frame(apply(x, MARGIN = 1, function(x) {
paste(sprintf("{%d,%d}",x[1], x[2]))
}))
y_bar <- as.vector.data.frame(rowMeans(x))
data2 <- data.frame(Sample, y_bar)
View(data2)
DT::datatable{
DT::datatable(
data2,
height=200
)
mean(x)
mean(x-mean(x))
x
y_bar.mean <- mean(y_bar)
x - y_bar.mean
mean(x-y_bar.mean)
mean((x-y_bar.mean)^2)
s_2.mean <- mean(s_2)
s_2.mean <- mean(s_2)
s_2 <- as.vector.data.frame(apply(x, MARGIN=1, function(x) {
var(x)
}))
data3 <- data.frame(data2, s_2)
s_2.mean <- mean(s_2)
s_2.mean
N*(N-1)*sigma
N/(N-1)*sigma
setwd("~/Documents/mycodes/Classes/Multivariate Statistical Analysis/week3")
ls
data = read.csv('./Book2.csv')
View(data)
View(data)
n - length(data)
n <- length(data)
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
npp <- sapply(data[,2:n], function(x) {
print(x)
qqnorm(data[[x]], main = x)
qqline(data[[x]])
})
data <- na.omit(data)
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
npp <- sapply(data[,2:n], function(x) {
print(x)
qqnorm(data[[x]], main = x)
qqline(data[[x]])
})
help(apply)
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
npp <- apply(data[,2:n], MARGIN = 2, function(x) {
print(x)
qqnorm(data[[x]], main = x)
qqline(data[[x]])
})
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
npp <- apply(data[,2:n], MARGIN = 2, function(x) {
print(x)
qqnorm(x, main = x)
qqline(x)
})
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
npp <- apply(data[,2:n], MARGIN = 2, function(x) {
# print(x)
qqnorm(x, main = x)
qqline(x)
})
npp
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
par(mfrom=c(1, n-1))
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
par(mfrow=c(1, n-1))
npp <- apply(data[,2:n], MARGIN = 2, function(x) {
# print(x)
qqnorm(x, main = x)
qqline(x)
})
npp <- apply(data[,2:n], MARGIN = 2, function(x) {
# print(x)
qqnorm(x, main = colnames(x))
qqline(x)
})
par(mfrow=c(1,1))
help(qqnorm)
npp <- apply(data[,2:n], MARGIN = 2, function(x) {
# print(x)
qqnorm(x, xlab=colnames(x))
qqline(x)
shapiro.test(x)
})
npp <- apply(2:n, MARGIN = 2, function(x) {
# print(x)
qqnorm(data[,x], xlab=colnames(data[,x]))
qqline(data[,x])
shapiro.test(data[,x])
})
npp <- apply(c(2:n), MARGIN = 2, function(x) {
# print(x)
qqnorm(data[,x], xlab=colnames(data[,x]))
qqline(data[,x])
shapiro.test(data[,x])
})
npp <- sapply(2:n, function(x) {
# print(x)
qqnorm(data[,x], xlab=colnames(data[,x]))
qqline(data[,x])
shapiro.test(data[,x])
})
npp
data = read.csv('./Book2.csv', header = T)
data <- na.omit(data)
npp <- sapply(2:n, function(x) {
# print(x)
qqnorm(data[,x], xlab=colnames(data[,x]))
qqline(data[,x])
shapiro.test(data[,x])
})
npp
names(data)
npp <- sapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], xlab=header[col])
qqline(data[,col])
shapiro.test(data[,col])
})
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], xlab=header[col])
qqline(data[,col])
shapiro.test(data[,col])
})
header <- names(data)
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], xlab=header[col])
qqline(data[,col])
shapiro.test(data[,col])
})
par(mfrow=c(1, n-1))
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], xlab=header[col])
qqline(data[,col])
shapiro.test(data[,col])
})
npp
help("shapiro.test")
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], main=header[col], xlab= )
qqline(data[,col])
print(shapiro.test(data[,col])$p.value)
})
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], main=header[col], xlab= ifelse(shapiro.test(data[,col])$p.value > 0.05, "Is Normal": "Not Normal"))
qqline(data[,col])
print(shapiro.test(data[,col])$p.value)
})
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], main=header[col], xlab= ifelse(shapiro.test(data[,col])$p.value > 0.05, "Is Normal", "Not Normal"))
qqline(data[,col])
print(shapiro.test(data[,col])$p.value)
})
npp
# 2. Tính “Generalised distance”.
S <- cov(data[, 2:n])
View(S)
dl.means <- colMeans(data[, 2:n])
# 2. Tính “Generalised distance”.
dl <- data[, 2:n]
S <- cov(dl)
dl.means <- colMeans(dl)
d_2 <- apply(dl, MARGIN=1, function(x) {
print(x)
t(x-dl.means) %*% solve(S) %*% (x-dl.means)
})
d_2
mah <- mahalanobis(dl, colMeans(dl), cov(dl))
mah
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(d), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
help(qchisq)
nrow(dl)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(dl), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
help(plot)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(d_2), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
par(mfrow=c(1,1))
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(d_2), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(d_2), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
abline(a=1, b=0)
abline(a=1, b=0)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(d_2), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=1, b=0)
abline(a=0, b=1)
# 4. Dữ liệu đã cho có phân phối chuẩn nhiều chiều không?
mvnormtest::mshapiro.test(dl)
install.packages(mvnormtest)
install.packages("mvnormtest")
# 4. Dữ liệu đã cho có phân phối chuẩn nhiều chiều không?
mvnormtest::mshapiro.test(dl)
View(dl)
typeof(dl)
# 4. Dữ liệu đã cho có phân phối chuẩn nhiều chiều không?
mvnormtest::mshapiro.test(as.matrix(dl))
View(dl)
matrix(unlist(dl), ncol=ncol(dl), byrow=T)
# 4. Dữ liệu đã cho có phân phối chuẩn nhiều chiều không?
m_dl <- matrix(unlist(dl), ncol=ncol(dl), byrow=T)
mvnormtest::mshapiro.test(m_dl)
mvnormtest::mshapiro.test(t(m_dl))
data = read.csv('./Book2.csv', header = T)
data <- na.omit(data)
n <- length(data)
header <- names(data)
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
par(mfrow=c(1, n-1))
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], main=header[col], xlab= ifelse(shapiro.test(data[,col])$p.value > 0.05, "Is Normal", "Not Normal"))
qqline(data[,col])
print(shapiro.test(data[,col])$p.value)
})
npp
par(mfrow=c(1,1))
# 2. Tính “Generalised distance”.
dl <- data[, 2:n]
S <- cov(dl)
dl.means <- colMeans(dl)
d_2 <- apply(dl, MARGIN=1, function(x) {
print(x)
t(x-dl.means) %*% solve(S) %*% (x-dl.means)
})
d_2
mah <- mahalanobis(dl, colMeans(dl), cov(dl))
mah
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(d_2), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
# 4. Dữ liệu đã cho có phân phối chuẩn nhiều chiều không?
# Vì các điểm không nằm trên đường thẳng => Không phân phối chuẩn nhiều chiều.
par(mfrow=c(1, n-1))
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], main=header[col], xlab= ifelse(shapiro.test(data[,col])$p.value > 0.05, "Is Normal", "Not Normal"))
qqline(data[,col])
print(shapiro.test(data[,col])$p.value)
})
npp
par(mfrow=c(1,1))
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=3), sort(d_2), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
data = read.csv('./table1.csv', header = T)
View(data)
data = read.csv('./Book2.csv', header = T)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=nrow(dl)), sort(d_2), xlab = expression(paste(chi[3]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=nrow(dl)), sort(d_2), xlab = expression(paste(chi[7]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=7, sort(d_2), xlab = expression(paste(chi[7]^2, " Quantitle")), ylab = "Ordered distances")
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=7, sort(d_2), xlab = expression(paste(chi[7]^2, " Quantitle")), ylab = "Ordered distances")
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=ncol(dl)), sort(d_2), xlab = expression(paste(chi[7]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=ncol(dl)), sort(d_2), xlab = expression(paste(chi[ncol(dl)]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
abline(a=0, b=1)
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=ncol(dl)), sort(d_2), xlab = expression(paste(chi[7]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
abline(a=0, b=1, colour='red')
abline(a=0, b=1, color='red')
abline(a=0, b=1)
dl1 = matrix(c(7,5,6,5, 3, 4, 4, 4), ncol = 2)
dl1 = matrix(c(7,5,6,5, 3, 4, 4, 4), ncol = 2)
View(dl1)
dl2 = matrix(c(6,5,7,5,6.5,5, 4,4,4,3,4,3), ncol=2)
View(dl2)
colMeans(dl1)
colMeans(dl2)
S1 = cov(dl1)
S2 = cov(dl2)
View(S1)
View(S2)
n1 = 4
n2 = 6
S = (n1-1)*S1 + (n2-1)*S2
View(S)
X_bar <- colMeans(dl1)
Y_bar <- colMeans(dl2)
T_2 = t(X_bar - Y_bar) %*% solve((1/n1+1/n2)*S) %*% (X_bar - Y_bar)
help(pf)
qf(2, n1, n2, ncp=0.05)
qf(2, dl1, dl2, ncp=0.05)
qf(2, n1, n2)
qf(.95, n1, n2)
qf(0.05, n1, n2)
qf(0.05, n1, n2, lower.tail = F)
qf(0.05, 2, n1+n2-p-1, lower.tail = F)
qf(0.05, 2, n1+n2-2-1, lower.tail = F)
qf(0.01, 2, n1+n2-2-1, lower.tail = F)
fish <- qf(0.01, 2, n1+n2-2-1, lower.tail = F)
fish * 8/7
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=ncol(dl)), sort(d_2), xlab = expression(paste(chi[7]^2, " Quantitle")), ylab = "Ordered distances")
data = read.csv('./Book2.csv', header = T)
data <- na.omit(data)
n <- length(data)
header <- names(data)
# 1. Vẽ “Normal probability plot” cho các biến trong dữ liệu. Từng biến có phân
# phối chuẩn 1 chiều không?
par(mfrow=c(1, n-1))
npp <- lapply(2:n, function(col) {
# print(col)
qqnorm(data[,col], main=header[col], xlab= ifelse(shapiro.test(data[,col])$p.value > 0.05, "Is Normal", "Not Normal"))
qqline(data[,col])
print(shapiro.test(data[,col])$p.value)
})
npp
par(mfrow=c(1,1))
# 2. Tính “Generalised distance”.
dl <- data[, 2:n]
S <- cov(dl)
dl.means <- colMeans(dl)
d_2 <- apply(dl, MARGIN=1, function(x) {
print(x)
t(x-dl.means) %*% solve(S) %*% (x-dl.means)
})
d_2
mah <- mahalanobis(dl, colMeans(dl), cov(dl))
mah
# 3. Vẽ “Chi-square plot” .
plot(qchisq((1:nrow(dl) - 1/2) / nrow(dl), df=ncol(dl)), sort(d_2), xlab = expression(paste(chi[7]^2, " Quantitle")), ylab = "Ordered distances")
abline(a=0, b=1)
# 4. Dữ liệu đã cho có phân phối chuẩn nhiều chiều không?
# Vì các điểm không nằm trên đường thẳng => Không phân phối chuẩn nhiều chiều.
